/// This module contains methods for discovering Sonos devices on the network.
library;

import 'dart:async';
import 'dart:io';

import 'package:logging/logging.dart';

import 'config.dart' as config;
import 'core.dart';

final _log = Logger('soco.discovery');

/// Helper function to create SoCo instances respecting the configured factory.
SoCo _createSoCoInstance(String ipAddress) {
  if (config.socoClassFactory != null) {
    return config.socoClassFactory!(ipAddress) as SoCo;
  }
  return SoCo(ipAddress);
}

/// The multicast group for SSDP discovery
const _mcastGroup = '239.255.255.250';

/// The multicast port for SSDP discovery
const _mcastPort = 1900;

/// The SSDP discovery message for Sonos ZonePlayers
const _playerSearch = '''M-SEARCH * HTTP/1.1
HOST: 239.255.255.250:1900
MAN: "ssdp:discover"
MX: 1
ST: urn:schemas-upnp-org:device:ZonePlayer:1

''';

/// Discover Sonos zones on the local network.
///
/// Returns a set of [SoCo] instances for each zone found.
/// Include invisible zones (bridges and slave zones in stereo pairs) if
/// [includeInvisible] is `true`. Will block for up to [timeout] seconds,
/// after which return `null` if no zones found.
///
/// Note that the presence of a [SoCo] object in the returned set is not a
/// guarantee that the associated Sonos player is currently contactable. This
/// is because the set of [SoCo] objects is generated by interrogating the
/// first discovered player to determine the current set of players, and this
/// data can lag the actual state of the system, e.g., if a speaker has been
/// recently switched off.
///
/// Parameters:
///   - [timeout]: block for this many seconds, at most. Defaults to 5.
///   - [includeInvisible]: include invisible zones in the return set.
///     Defaults to `false`.
///   - [interfaceAddr]: Discovery operates by sending UDP multicast datagrams.
///     [interfaceAddr] is an IP address (dotted quad) representation of the
///     network interface to use as the source of the datagrams. If `null` or
///     not specified, the system default interface(s) for UDP multicast
///     messages will be used. This is probably what you want to happen.
///     Defaults to `null`.
///   - [householdId]: Supply a Sonos Household ID to restrict discovery to a
///     specific household. Useful in multi-household networks. In the default
///     case the first player to respond will be used.
///   - [allowNetworkScan]: If normal discovery fails, fall back to a scan of
///     the attached network(s) to detect Sonos devices.
///   - [scanNetworkKwargs]: Arguments for the [scanNetwork] function.
///
/// Returns:
///   A set of [SoCo] instances, one for each zone found, or else `null`.
Future<Set<SoCo>?> discover({
  int timeout = 5,
  bool includeInvisible = false,
  String? interfaceAddr,
  String householdId = 'Sonos',
  bool allowNetworkScan = false,
  Map<String, dynamic> scanNetworkKwargs = const {},
}) async {
  // Validate interface address if provided
  Set<String> addresses;
  if (interfaceAddr != null) {
    try {
      InternetAddress.tryParse(interfaceAddr);
      addresses = {interfaceAddr};
      _log.fine(
        'Sending discovery packets on specified interface $interfaceAddr',
      );
    } catch (e) {
      throw ArgumentError('$interfaceAddr is not a valid IP address string');
    }
  } else {
    // Use all qualified, discovered network interfaces
    addresses = await _findIpv4Addresses();
    if (addresses.isEmpty) {
      _log.fine('No interfaces available for discovery');
      return null;
    }
    _log.fine(
      'Sending discovery packets on discovered interface(s) $addresses',
    );
  }

  // Create sockets for each interface
  final sockets = <RawDatagramSocket>[];
  for (final address in addresses) {
    try {
      final socket = await RawDatagramSocket.bind(address, 0);
      // Set multicast options
      socket.multicastLoopback = false;
      socket.multicastHops = 4; // UPnP v1.0 requires a TTL of 4
      sockets.add(socket);
      _log.fine('Created socket for $address');
    } catch (e) {
      _log.warning('Cannot make a discovery socket for $address: $e');
    }
  }

  if (sockets.isEmpty) {
    _log.fine('Failed to create any discovery sockets');
    return null;
  }

  // Send discovery packets (a few times, since UDP is unreliable)
  final dest = InternetAddress(_mcastGroup);
  final searchBytes = _playerSearch.codeUnits;

  for (var i = 0; i < 3; i++) {
    for (final socket in [...sockets]) {
      _log.fine('Sending discovery packet on $socket');
      try {
        socket.send(searchBytes, dest, _mcastPort);
      } catch (e) {
        _log.fine('Sending failed $e: removing $socket from sockets list');
        sockets.remove(socket);
        socket.close();
      }
    }
  }

  if (sockets.isEmpty) {
    _log.fine('Sending failed on all interfaces');
    return null;
  }

  // Listen for responses
  final responseCompleter = Completer<Set<SoCo>?>();

  // Set up listeners for all sockets
  for (final socket in sockets) {
    socket.listen((event) {
      if (event == RawSocketEvent.read) {
        final datagram = socket.receive();
        if (datagram != null) {
          final data = String.fromCharCodes(datagram.data);
          _log.fine(
            'Received discovery response from ${datagram.address}: "$data"',
          );

          // Check if response contains the household ID
          if (data.contains(householdId)) {
            // We found a zone! Build a SoCo instance and query for topology
            final zone = _createSoCoInstance(datagram.address.address);

            // Close all sockets
            for (final s in sockets) {
              s.close();
            }

            // Complete with the appropriate zones
            if (!responseCompleter.isCompleted) {
              if (includeInvisible) {
                zone.allZones.then((zones) {
                  if (!responseCompleter.isCompleted) {
                    responseCompleter.complete(zones);
                  }
                });
              } else {
                zone.visibleZones.then((zones) {
                  if (!responseCompleter.isCompleted) {
                    responseCompleter.complete(zones);
                  }
                });
              }
            }
          }
        }
      }
    });
  }

  // Set up timeout
  Timer(Duration(seconds: timeout), () {
    if (!responseCompleter.isCompleted) {
      _log.fine('Discovery timeout');
      for (final socket in sockets) {
        socket.close();
      }
      responseCompleter.complete(null);
    }
  });

  // Wait for either a response or timeout
  final result = await responseCompleter.future;

  // If discovery failed and network scan is allowed, try that
  if (result == null && allowNetworkScan) {
    _log.fine('Falling back to network scan discovery');
    if (householdId == 'Sonos') {
      return scanNetwork(
        includeInvisible: includeInvisible,
        multiHousehold: scanNetworkKwargs['multiHousehold'] as bool? ?? false,
        maxThreads: scanNetworkKwargs['maxThreads'] as int? ?? 256,
        scanTimeout: scanNetworkKwargs['scanTimeout'] as double? ?? 0.5,
        minNetmask: scanNetworkKwargs['minNetmask'] as int? ?? 24,
        networksToScan: scanNetworkKwargs['networksToScan'] as List<String>?,
      );
    } else {
      return scanNetworkByHouseholdId(
        householdId,
        includeInvisible: includeInvisible,
        maxThreads: scanNetworkKwargs['maxThreads'] as int? ?? 256,
        scanTimeout: scanNetworkKwargs['scanTimeout'] as double? ?? 0.5,
        minNetmask: scanNetworkKwargs['minNetmask'] as int? ?? 24,
        networksToScan: scanNetworkKwargs['networksToScan'] as List<String>?,
      );
    }
  }

  return result;
}

/// Return any visible SoCo device, for when it doesn't matter which.
///
/// Try to obtain an existing instance, or use [discover] if necessary.
/// Note that this assumes that the existing instance has not left the network.
///
/// Parameters:
///   - [allowNetworkScan]: If normal discovery fails, fall back to a scan of
///     the attached network(s) to detect Sonos devices.
///   - [scanNetworkKwargs]: Arguments for the [scanNetwork] function.
///
/// Returns:
///   A [SoCo] instance, or `null` if no instances are found.
Future<SoCo?> anySoco({
  bool allowNetworkScan = false,
  Map<String, dynamic> scanNetworkKwargs = const {},
}) async {
  // Try to get the first pre-existing SoCo instance we know about,
  // as long as it is visible (i.e. not a bridge etc)
  try {
    final instances = SoCo.instances.values;
    for (final device in instances) {
      if (await device.isVisible) {
        return device;
      }
    }
  } catch (e) {
    // No instances found, fall through to discovery
  }

  // Perform discovery and return one of the found devices
  final devices = await discover(
    allowNetworkScan: allowNetworkScan,
    scanNetworkKwargs: scanNetworkKwargs,
  );

  return (devices == null || devices.isEmpty) ? null : devices.first;
}

/// Return a device by name.
///
/// Parameters:
///   - [name]: The name of the device to return.
///   - [allowNetworkScan]: If normal discovery fails, fall back to a scan of
///     the attached network(s) to detect Sonos devices.
///   - [scanNetworkKwargs]: Arguments for the [scanNetwork] function.
///
/// Returns:
///   A [SoCo] instance, or `null` if no device with the given name is found.
Future<SoCo?> byName(
  String name, {
  bool allowNetworkScan = false,
  Map<String, dynamic> scanNetworkKwargs = const {},
}) async {
  final devices = await discover(
    allowNetworkScan: allowNetworkScan,
    scanNetworkKwargs: scanNetworkKwargs,
  );

  if (devices == null) {
    return null;
  }

  for (final device in devices) {
    if (await device.playerName == name) {
      return device;
    }
  }

  return null;
}

/// Scan all attached networks for Sonos devices.
///
/// This function scans the IPv4 networks to which this node is attached,
/// searching for Sonos devices. Multiple parallel isolates are used to
/// scan IP addresses in parallel for faster discovery.
///
/// Public, loopback and link local IP ranges are excluded from the scan,
/// and the scope of the search can be controlled by setting a minimum netmask.
/// Alternatively, a list of networks to scan can be provided.
///
/// This function is intended for use when the usual discovery function is not
/// working, perhaps due to multicast problems on the network to which the SoCo
/// host is attached. The function can also be used to find a complete list of
/// speakers when there are multiple Sonos households present.
/// For example, this is the case where there are 'split' S1/S2 Sonos systems
/// on the network.
///
/// Note that this call may fail to find speakers present on the network, and
/// this can be due to ARP cache misses and ARP requests that don't
/// complete within the timeout. The call can be retried with longer values for
/// [scanTimeout] if necessary.
///
/// Note also that the presence of a [SoCo] object in the returned set is not a
/// guarantee that the associated Sonos player is currently contactable. This
/// is because the set of [SoCo] objects is partly generated by interrogating
/// discovered players to determine the current set(s) of players, and this can
/// lag the actual state of the system, e.g., if a speaker has been recently
/// switched off.
///
/// Parameters:
///   - [includeInvisible]: Whether to include invisible Sonos devices in the
///     set of devices returned.
///   - [multiHousehold]: Whether to find all the speakers on the network
///     exhaustively. If set to `false`, discovery will stop as soon as at
///     least one speaker is found. In the case of multiple households on the
///     attached networks, this means that only the speakers from the
///     first-discovered household will be returned. If set to `true`,
///     discovery will proceed until all speakers, from all households, have
///     been found.
///   - [maxThreads]: The maximum number of concurrent isolates to use when
///     scanning the network.
///   - [scanTimeout]: The network timeout in seconds to use when checking each
///     IP address for a Sonos device.
///   - [minNetmask]: The minimum number of netmask bits. Used to constrain the
///     network search space.
///   - [networksToScan]: A list of IPv4 networks to search, each a string of
///     form "192.168.0.1/24". Only the specified networks will be searched.
///     The [minNetmask] option (if supplied) is ignored.
///
/// Returns:
///   A set of [SoCo] instances, one for each zone found, or else `null`.
Future<Set<SoCo>?> scanNetwork({
  bool includeInvisible = false,
  bool multiHousehold = false,
  int maxThreads = 256,
  double scanTimeout = 0.5,
  int minNetmask = 24,
  List<String>? networksToScan,
}) async {
  // Generate the set of IPs to check
  final ipSet = <InternetAddress>{};

  if (networksToScan != null) {
    for (final networkToScan in networksToScan) {
      try {
        // Parse network CIDR notation (e.g., "192.168.0.0/24")
        final parts = networkToScan.split('/');
        if (parts.length != 2) {
          _log.fine('\'$networkToScan\' is not a valid IPv4 network');
          continue;
        }

        final baseAddr = InternetAddress(parts[0]);
        final netmaskBits = int.parse(parts[1]);

        // Generate all IPs in this network
        final ips = _generateIpRange(baseAddr.address, netmaskBits);
        ipSet.addAll(ips);
      } catch (e) {
        _log.fine('\'$networkToScan\' is not a valid IPv4 network: $e');
        continue;
      }
    }
  } else {
    final networks = await _findIpv4Networks(minNetmask);
    for (final network in networks) {
      ipSet.addAll(network);
    }
  }

  // Find Sonos devices on the list of IPs
  // Use concurrent futures to scan the list efficiently
  final sonosIpAddresses = <String>[];
  final stopScan = <bool>[false]; // Shared flag to stop scanning

  final actualMaxThreads = maxThreads < ipSet.length
      ? maxThreads
      : ipSet.length;
  final ipList = ipSet.toList();
  final chunkSize = (ipList.length / actualMaxThreads).ceil();

  final futures = <Future<void>>[];
  for (var i = 0; i < actualMaxThreads; i++) {
    final start = i * chunkSize;
    final end = (start + chunkSize < ipList.length)
        ? start + chunkSize
        : ipList.length;

    if (start >= ipList.length) break;

    final chunk = ipList.sublist(start, end);
    futures.add(
      _scanIpChunk(
        chunk,
        scanTimeout,
        sonosIpAddresses,
        multiHousehold,
        stopScan,
      ),
    );
  }

  _log.fine('Created ${futures.length} scanner tasks');

  // Wait for all tasks to finish
  await Future.wait(futures);
  _log.fine('All ${futures.length} scanner tasks terminated');

  // No Sonos devices found
  if (sonosIpAddresses.isEmpty) {
    _log.fine('No Sonos zones discovered');
    return null;
  }

  // Collect SoCo instances
  final zones = <SoCo>{};
  for (final ipAddress in sonosIpAddresses) {
    final device = _createSoCoInstance(ipAddress);

    if (includeInvisible) {
      zones.addAll(await device.allZones);
    } else {
      zones.addAll(await device.visibleZones);
    }

    // Stop after first zone unless we want exhaustively to find
    // all zones across all households
    if (!multiHousehold) {
      break;
    }
  }

  _log.fine(
    'includeInvisible: $includeInvisible | multiHousehold: $multiHousehold | '
    '${zones.length} Zones: $zones',
  );

  return zones;
}

/// Convenience function to find the zones in a specific Sonos household.
///
/// Parameters:
///   - [householdId]: The Sonos household ID to search for. IDs take the form
///     'Sonos_XXXXXXXXXXXXXXXXXXXXXXXXXX'.
///   - [includeInvisible]: Whether to include invisible Sonos devices in the
///     set of devices returned.
///   - Other parameters are the same as [scanNetwork].
///
/// Returns:
///   A set of [SoCo] instances, one for each zone found, or else `null`.
Future<Set<SoCo>?> scanNetworkByHouseholdId(
  String householdId, {
  bool includeInvisible = false,
  int maxThreads = 256,
  double scanTimeout = 0.5,
  int minNetmask = 24,
  List<String>? networksToScan,
}) async {
  // multiHousehold must be set to true
  var zones = await scanNetwork(
    includeInvisible: includeInvisible,
    multiHousehold: true,
    maxThreads: maxThreads,
    scanTimeout: scanTimeout,
    minNetmask: minNetmask,
    networksToScan: networksToScan,
  );

  if (zones != null) {
    final filtered = <SoCo>{};
    for (final zone in zones) {
      final hid = await zone.householdId;
      if (householdId == hid) {
        filtered.add(zone);
      }
    }
    zones = filtered;
  }

  _log.fine('Returning zones: $zones');
  return zones;
}

///////////////////////////////////////////////////////////////////////////////
// HELPER FUNCTIONS                                                          //
///////////////////////////////////////////////////////////////////////////////

/// Discover and return all the host's IPv4 addresses.
///
/// Helper function to return a set of IPv4 addresses associated with the
/// network interfaces of this host. Loopback and link local addresses are
/// excluded.
///
/// Returns:
///   A set of IPv4 addresses (dotted decimal strings). Empty set if there are
///   no addresses found.
Future<Set<String>> _findIpv4Addresses() async {
  final ipv4Addresses = <String>{};

  final interfaces = await NetworkInterface.list(
    includeLoopback: false,
    type: InternetAddressType.IPv4,
  );

  for (final interface in interfaces) {
    for (final addr in interface.addresses) {
      // Skip loopback and link-local addresses
      if (addr.isLoopback || addr.isLinkLocal) {
        continue;
      }
      ipv4Addresses.add(addr.address);
    }
  }

  _log.fine('Set of attached IPs: $ipv4Addresses');
  return ipv4Addresses;
}

/// Discover attached IP networks.
///
/// Helper function to return a set of IPv4 networks to which the network
/// interfaces on this node are attached. Exclude public, loopback and link
/// local network ranges.
///
/// Parameters:
///   - [minNetmask]: The minimum netmask to be used.
///
/// Returns:
///   A set of IP address sets, each representing a network.
Future<Set<Set<InternetAddress>>> _findIpv4Networks(int minNetmask) async {
  final ipv4NetList = <Set<InternetAddress>>{};

  final interfaces = await NetworkInterface.list(
    includeLoopback: false,
    type: InternetAddressType.IPv4,
  );

  for (final interface in interfaces) {
    for (final addr in interface.addresses) {
      // Skip loopback and link-local addresses
      if (addr.isLoopback || addr.isLinkLocal) {
        continue;
      }

      // Check if this is a private network
      final ipParts = addr.address.split('.').map(int.parse).toList();
      final isPrivate = _isPrivateNetwork(ipParts);

      if (!isPrivate) {
        continue;
      }

      // Generate the network range
      // Use the minimum netmask to constrain the search space
      final ips = _generateIpRange(addr.address, minNetmask);
      if (ips.isNotEmpty) {
        ipv4NetList.add(ips);
      }
    }
  }

  _log.fine('Set of networks to search: $ipv4NetList');
  return ipv4NetList;
}

/// Check if an IP address is in a private network range.
bool _isPrivateNetwork(List<int> ipParts) {
  // Private network ranges:
  // 10.0.0.0/8
  // 172.16.0.0/12
  // 192.168.0.0/16
  if (ipParts[0] == 10) {
    return true;
  }
  if (ipParts[0] == 172 && ipParts[1] >= 16 && ipParts[1] <= 31) {
    return true;
  }
  if (ipParts[0] == 192 && ipParts[1] == 168) {
    return true;
  }
  return false;
}

/// Generate all IP addresses in a network given a base address and netmask.
Set<InternetAddress> _generateIpRange(String baseAddr, int netmaskBits) {
  final ips = <InternetAddress>{};

  final ipParts = baseAddr.split('.').map(int.parse).toList();
  final ipInt =
      (ipParts[0] << 24) | (ipParts[1] << 16) | (ipParts[2] << 8) | ipParts[3];

  final mask = (~0 << (32 - netmaskBits)) & 0xFFFFFFFF;
  final networkAddr = ipInt & mask;
  final hostCount = 1 << (32 - netmaskBits);

  // Generate all host addresses in the network
  for (var i = 1; i < hostCount - 1; i++) {
    // Skip network and broadcast addresses
    final hostAddr = networkAddr + i;
    final a = (hostAddr >> 24) & 0xFF;
    final b = (hostAddr >> 16) & 0xFF;
    final c = (hostAddr >> 8) & 0xFF;
    final d = hostAddr & 0xFF;

    try {
      ips.add(InternetAddress('$a.$b.$c.$d'));
    } catch (e) {
      // Invalid address, skip
    }
  }

  return ips;
}

/// Helper function to check if a port is open.
///
/// Parameters:
///   - [ipAddress]: The IP address to be checked.
///   - [port]: The port to be checked.
///   - [timeout]: The timeout to use.
///
/// Returns:
///   `true` if a connection can be made.
Future<bool> _checkIpAndPort(String ipAddress, int port, double timeout) async {
  try {
    final socket = await Socket.connect(
      ipAddress,
      port,
      timeout: Duration(milliseconds: (timeout * 1000).toInt()),
    );
    socket.destroy();
    return true;
  } catch (e) {
    return false;
  }
}

/// Helper function to check if this is a Sonos device.
///
/// Parameters:
///   - [ipAddress]: The IP address to be checked.
///
/// Returns:
///   `true` if there is a Sonos device at the address.
Future<bool> _isSonos(String ipAddress) async {
  try {
    // Try getting a device property
    final device = _createSoCoInstance(ipAddress);
    await device.isVisible;
    return true;
  } catch (e) {
    return false;
  }
}

/// Scan a chunk of IP addresses for Sonos devices.
///
/// Parameters:
///   - [ipChunk]: List of IP addresses to scan.
///   - [socketTimeout]: Timeout for socket connections.
///   - [sonosIpAddresses]: Shared list to add found Sonos IPs to.
///   - [multiHousehold]: Whether to continue scanning after finding one device.
///   - [stopScan]: Shared flag to stop scanning.
Future<void> _scanIpChunk(
  List<InternetAddress> ipChunk,
  double socketTimeout,
  List<String> sonosIpAddresses,
  bool multiHousehold,
  List<bool> stopScan,
) async {
  for (final ipAddr in ipChunk) {
    // Check if we should stop scanning
    if (stopScan[0]) {
      break;
    }

    final ipAddress = ipAddr.address;

    _log.finer('Scanning port $ipAddress:1400');

    // Check if port 1400 is open
    final check = await _checkIpAndPort(ipAddress, 1400, socketTimeout);

    if (check) {
      _log.fine('Found open port 1400 at IP \'$ipAddress\'');

      // Check if it's a Sonos device
      if (await _isSonos(ipAddress)) {
        _log.fine('Confirmed Sonos device at IP \'$ipAddress\'');
        sonosIpAddresses.add(ipAddress);

        // Stop scanning if we're not doing an exhaustive search
        if (!multiHousehold) {
          stopScan[0] = true;
          break;
        }
      } else {
        _log.finer('Device at IP \'$ipAddress\' is not a Sonos device');
      }
    }
  }
}
